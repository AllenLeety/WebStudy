1.压缩包管理
	（1）tar--不使用z/j参数，该命令只能对文件或目录打包
		参数：
		   c -- 创建 --压缩
		   x -- 释放 --解压缩
		   v -- 显示提示信息 -- 压缩解压缩 -- 可以省略
		   f -- 指定压缩文件的名字

		   z -- 使用gzip的方式压缩文件 -- .gz
		   j -- 使用bzip2的方式压缩文件 -- .bz2
		压缩：
			tar zcvf 生成的压缩包的名字（xxx.tar.gz）要压缩的文件或目录
			tar jcvf 生成的压缩包的名字(xxx.tar.bz2)要压缩的文件或目录
		解压缩：
			tar jxvf 压缩包的名字（解压到当前目录）
			tar jxvf 压缩包名字 -C 解压缩的目录
	（2）rar -- 必须手动安装该软件
		参数：
			压缩 a
			解压缩 x
		压缩：
			rar a 生成的压缩文件的名字（不需要加后缀.rar，会自动添加） 压缩的文件或目录
		解压缩：
			rar x 压缩文件 （解压缩的目录）
	（3）zip
		压缩：
			zip 压缩包的名字 压缩的文件或目录
		解压缩：
			unzip 压缩包的名字   （解压到当前目录）
			unzip 压缩包的名字 -d 解压目录  （解压到指定的目录）
	总结
		压缩	tar/rar/zip 参数 生成的压缩文件的名字 压缩的文件或目录
		解压	tar/rar/zip 参数 压缩包的名字 参数（rar没有参数） 解压缩目录
2.ftp服务器搭建--vsftpd
	作用：文件的上传和下载
	（1）服务器端
		1）修改配置文件--如何修改配置文件
			sudo vim /etc/vsftpd.conf进入文件修改
		2）重启服务--什么命令能够重启服务
			sudo service vsftpd restart
	(2)客户端
		1）实名用户登录
			ftp + IP(server)
			输入用户名（server）
			输人密码

			文件的上传和下载
				文件的上传：put file名字
				文件的下载：get file名字
				不允许操作目录，如果想操作目录先压缩再传输
		2）用户匿名登录
			ftp + serverIP
			用户名： anonymous
			密码： 直接回车

			不允许匿名用户在任意目录直接切换
			只能在一个指定的目录范围内工作
			需要在ftp服务器上创建一个匿名用户的目录 -- 匿名用户的根目录
		3）lftp客户端访问ftp服务器
3.nfs服务器的使用
	net file system网络文件系统，它允许网络中的计算机之间通过TCP/IP网络共享资源
	安装 sudo apt-get install nfs-kernel-server
	创建一个欲共享出去的目录 如：/home/xxx/xxx
	打开配置文件：sudo vim /etc/exports
	（1）服务器端
		1）创建共享目录
			mkdir dir
		2）修改配置文件
			/etc/exports
		3）重启服务
			sudo service nfs-kernel-server restart
	（2）客户端
		1）挂载服务器共享目录
			mount serverIP:sharedir /mnt
4.ssh服务器
	(1)服务器端
		安装ssh： sudo apt-get install openssh-server
	(2)远程登录 
		ssh 用户名@IP    确认连接的时候一定要写yes/no
	(3)退出登录  logout
5.静态库的制作
	（1）命名规则
		1）lib + 库的名字 + .a
		2) 例如：libMytest.a
	（2）制作步骤
		1)生成对应的.o文件   
			gcc -c *.c
		2)将生成的.o文件打包  
			ar rcs 静态库的名字（libMytest.a） 生成的所有.o文件
		3)使用
			gcc main.c (库) -LlibPath -llinname -o app -Iinclude
			main.c -L -l
	（3）发布和使用静态库
		1）发布静态库
		2）头文件
	（4）优缺点
6.共享库的制作
	（1）命名规则
		lib名字.so   libMyshare.so
	（2）制作步骤	
		1）生成位置无关的.o文件
			gcc -fPIC -c *.c -I 头文件
		2)将.o打包成.so文件
			gcc -shared -o libMyshare.so *.o -I 头文件
			ldd 共享库名字      查看所有依赖的共享库
	（3）发布和使用共享库
		gcc main.c -Llib -lMyshare -I头文件 -o app
	（4）解决程序执行时动态库无法加载的问题
		1)临时设置的方法：
			export LD_LIBRARY_PATH=路径
		2）永久设置的方法：
			a.找到动态链接库的配置文件：/etc/ld.so.conf
			b.在该文件中添加动态库的目录（绝对路径）
			c.更新：sudo ldconfig -v
7.gdb调试
	（1）启动gdb
		start -- 只执行一步
		n -- next 单步执行
		s -- step（但不执行） -- 可以进入到函数体内部
		c -- continue -- 直接停在断点的位置
	（2）查看代码
		l -- list
		l 行号或函数名   -- 查看当前执行文件
		l filename:行号或函数名 -- 查看filename文件
	（3）设置断点
		1）设置当前文件断点：
			b -- break
			b 行号或函数名
		2）设置指定文件断点
			b filename:行号或函数名
		3）设置条件断点
			b 行号 if 条件
		4）删除断点
			d 断点的编号
			获取断点的编号：info -- i
				info b
	（4）查看设置的断点
		info b
	（5）开始 执行gdb调试
		执行一步操作：start
		继续执行：n s
		执行多步，直接停在断点处：c
	（6）单步调试
		进入函数体内部：s
		从函数体内部跳出：finish
		不进入函数体内部：n
		退出当前循环：u
	（7）查看变量的值：p 变量名
	（8）查看变量的类型：ptype 变量名
	（9）设置变量的值：set var 变量名=值
	（10）设置追踪变量：display
		取消追踪变量：undisplay 编号
		获取编号：info display
	（11）退出gdb调试：quit
8.makefile的编写
	(1)一个规则
		三要素：目标 依赖 命令
		目标:依赖
			命令

		第一条规则是用来生成终极目标的规则
			如果规则中的依赖不存在，向下寻找其他的规则
			更新机制：比较的是目标文件和依赖文件的时间
	（2）两个函数
		1）查找指定目录下，指定类型的文件
			src=$(wildcard ~/aa/*.c)
		2）匹配替换函数
			将.c文件替换为.o文件
			obj=$(patsubst %.c, %.o, $(src))
	（3）三个自动变量
		1) $<  ---规则中的第一个依赖
		2）$^  ---规则中的所有依赖
		3）$@  ---规则中的目标
		只能在规则中的命令中使用
	（4）模式规则
		%.o:%.c     ---.c文件生成.o文件
			gcc -c $< -o $@

